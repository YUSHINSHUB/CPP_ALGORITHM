
/*
commented by ChatGPT
This C++ code is designed to simulate the formation of dragon curves on a grid. Each dragon curve is generated by iterating over a sequence of turns and extending the curve one step at a time.
The code aims to count the number of complete 1x1 squares formed by these dragon curves on a 101x101 grid.
It takes the starting position, initial direction, and the number of generations as input for each curve.
After generating all curves, the program calculates the total number of squares where all four corners are part of the dragon curves.

이 C++ 코드는 그리드 위에서 용곡선의 형성을 시뮬레이션하기 위해 설계되었습니다. 각 용곡선은 일련의 회전을 반복하며 한 단계씩 곡선을 확장하여 생성됩니다.
이 코드의 목적은 이러한 용곡선들에 의해 형성된 101x101 그리드 위의 완전한 1x1 정사각형의 수를 세는 것입니다. 프로그램은 각 곡선에 대해 시작 위치, 초기 방향, 그리고 세대 수를 입력으로 받습니다.
모든 곡선을 생성한 후, 프로그램은 용곡선의 네 모서리 모두에 해당하는 정사각형의 총 수를 계산합니다.
*/

#include <iostream>
#include <vector>

using namespace std;

static bool grid[101][101]; // 101x101 크기의 그리드를 나타내는 이차원 배열
static vector<int> full; // 용곡선의 전체 방향을 저장하는 배열
static int gen; // 용곡선을 생성할 세대 수

// 용곡선을 생성하는 재귀 함수
static void curve(int cur, int y, int x, vector<int> dir) {

	if (cur > gen) // 현재 세대가 설정된 세대를 초과하면 재귀 종료
		return;

	vector<int> next; // 다음 세대의 방향을 저장할 배열

	for (int i = 0; i < dir.size(); i++) {
		full.push_back(dir[i]); // 현재 세대의 방향을 전체 배열에 추가
		switch (dir[i]) { // 방향에 따라 x, y 좌표를 업데이트
		case 0: // 오른쪽
			x++;
			break;
		case 1: // 위쪽
			y--;
			break;
		case 2: // 왼쪽
			x--;
			break;
		case 3: // 아래쪽
			y++;
			break;
		}
		grid[y][x] = true; // 해당 좌표를 true로 설정하여 곡선 표시
	}

	// 다음 세대의 방향을 계산
	for (int i = full.size() - 1; i >= 0; i--) {
		switch (full[i]) { // 현재 방향을 기준으로 다음 방향을 결정
		case 0: // 오른쪽에서 위쪽으로
			next.push_back(1);
			break;
		case 1: // 위쪽에서 왼쪽으로
			next.push_back(2);
			break;
		case 2: // 왼쪽에서 아래쪽으로
			next.push_back(3);
			break;
		case 3: // 아래쪽에서 오른쪽으로
			next.push_back(0);
			break;
		}
	}

	curve(cur + 1, y, x, next); // 다음 세대에 대한 재귀 호출
}

int main() {
	int res = 0; // 결과를 저장할 변수 (정사각형의 수)
	int N, dir, y, x; // 용곡선의 수, 시작 방향, 시작 y 좌표, 시작 x 좌표

	// 그리드 초기화
	for (int i = 0; i <= 100; i++) {
		fill(grid[i], grid[i] + 101, false);
	}
	cin >> N; // 용곡선의 수 입력 받기

	for (int i = 0; i < N; i++) {
		full.clear(); // 용곡선의 전체 방향 배열 초기화
		vector<int> list; // 현재 세대의 방향을 저장할 배열
		cin >> x >> y >> dir >> gen; // 시작 좌표, 방향, 세대 입력 받기
		grid[y][x] = true; // 시작점을 true로 설정
		list.push_back(dir); // 시작 방향 추가
		curve(0, y, x, list); // 용곡선 생성 함수 호출
	}

	// 정사각형의 수 계산
	for (int i = 0; i < 100; i++) {
		for (int j = 0; j < 100; j++) {
			if (grid[i][j] && grid[i + 1][j] && grid[i][j + 1] && grid[i + 1][j + 1])
				res++; // 네 꼭지점 모두 true인 경우 정사각형 카운트
		}
	}

	cout << res; // 결과 출력
}





